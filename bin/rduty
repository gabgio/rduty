#!/usr/bin/python3
try:
    import argparse
except:
    raise Exception("Missing argparse!")
try:
    import getpass
except:
    raise Exception("Missing getpass!")
try:
    import paramiko
except:
    raise Exception("Missing paramiko!")



import sys
from socket import error

PACKAGE="rduty"
VERSION="0.1"
RELEASE_DATE="20200101"
AUTHOR="Gabriele Giorgetti"
EMAIL="<g.giorgetti@gmail.com>"
URL="https://github.com/gabgio/rduty"

# exit values
EXIT_SUCCESS=0
EXIT_FAILURE=1

# supported protocols
PROTOCOL_SSH="ssh"
PROTOCOL_TELNET="telnet"

# defaults
PORT_SSH=22
PORT_TELNET=21

# elimina i warning deprecated
import warnings
warnings.filterwarnings(action='ignore',module='.*paramiko.*')


def _msgout(msg=""):
    if msg != "":
        sys.stdout.write(msg)

class User:
    def __init__(self):
        self.username=None
        self.password=None
    
    def Set (self, username=None, password=None):
        if username != None:
            self.username=username
        if password != None:
            self.password=password

    def SetFromArgs (self, arg_username, arg_password):

        if arg_username != None:
            if arg_password != None:
                self.Set(arg_username,arg_password)
            else:
                self.Ask(ask_username=False, ask_password=True)
                self.Set(username=arg_username)
        else:
            self.Ask(ask_username=True, ask_password=True)


    def Ask(self, ask_username=True,ask_password=True):
        if ask_username:
            self.username=input("Username: ")
        if ask_password:
            self.password=getpass.getpass()


class Hosts:
    def __init__(self):
        self.hosts=[]

    def AddFromArgs(self, args):
        # process args
        self.hosts=args.split(",")

""" global HOSTS
    for host in arg_hosts:
        if string.find(host,',') > -1:
            HOSTS.extend(string.split(host,','))
        else:
            HOSTS.append(host) """


class Connection:
    
    def __init__ (self,protocol):

        self.protocol=protocol

        self.hostname=""
        self.port=22
        self.username=""
        self.password=""
        
        self.connection=None
        self.connected=False

        self.outoput=None
        self.error=None

        if self.protocol is PROTOCOL_SSH:
            self.connection=paramiko.client.SSHClient()
            self.connection.load_system_host_keys()
            self.connection.set_missing_host_key_policy(paramiko.client.AutoAddPolicy())

        elif self.protocol is PROTOCOL_TELNET:
            pass
        else:
            self.error="Error, no protocol given!"
            return None


    def Connect (self, hostname=None, port=None, username=None,password=None):

        self.hostname=hostname
        self.username=username
        self.password=password

        if self.protocol is PROTOCOL_SSH:
            if port == None:
                self.port=PORT_SSH
            
            if self.ConnectSSH(self.hostname,self.port, self.username, self.password):
                return True

        elif self.protocol is PROTOCOL_TELNET:
            if port == None:
                self.port=PORT_TELNET

            if self.ConnectTELNET(self.hostname,self.port, self.username, self.password):
                return True

        return False


    def ConnectSSH (self, hostname=None,port=None,username=None,password=None):

        self.hostname=hostname
        self.port=port
        self.username=username
        self.password=password

        try:
            self.connection.connect(self.hostname, self.port,self.username,self.password)
        except paramiko.BadHostKeyException:
            self.error="Error (Connect), bad host key exception!"
            return False

        except paramiko.AuthenticationException:
            self.error="Error (Connect), bad username or password!"
            return False
        except paramiko.SSHException:
            self.error="Error (Connect), general ssh exception!"
            return False

        except socket.error:
            self.error="Error (Connect), general socket error!"
            return False

        self.connected=True
        return True


    def ConnectTELNET (self, hostname,port=21,username=None,password=None):
        self.hostname=hostname
        self.port=port
        self.username=username
        self.password=password

        try:
            self.connection = telnetlib.Telnet(self.hostname)
        except:
            self.error="Error (ConnectTELNET), can't connect!"
            return False

        t.read_until(b"Username:")
        t.write(self.username.encode("ascii") + b"\n")
        if password:
            t.read_until(b"Password:")
            t.write(self.password.encode("ascii") + b"\n")

        self.connected=True
        return True

    def Exec (self, command):
        self.command=command
        if not self.connected:
            return 

        if self.protocol is PROTOCOL_SSH:
            try:
                stdin , stdout, stderr = self.connection.exec_command(command)
            except paramiko.SSHException:
                self.error="Error (Exec), general ssh exception!"
                return False
            self.output = stdout.read().decode('ascii').strip("\n")
            return True
            
        elif self.protocol is PROTOCOL_TELNET:
            self.connection.write(self.command+"\n")
            #tn.write("exit\n")
            self.output=connection.read_all()
            return True

        return False


    def Output (self):
        return str(self.output)

    def Error (self):
        return str(self.error)


    def Close(self):
        if not self.connected:
            return

        try:
            self.client.close()
        except:
            pass


def show_version():
    sys.stdout.write ("%s %s (%s) (%s)\n" %(PACKAGE,VERSION,RELEASE_DATE,URL))
    sys.stdout.write ("\n")
    sys.stdout.write ("Written by %s %s\n" %(AUTHOR,EMAIL))
    

def main():
    """ """

    argparser = argparse.ArgumentParser(prog="rduty", add_help=True)

    # this command are mutually exclusive for command or script file, and at least one must be specified
    exclusive_actions_group = argparser.add_mutually_exclusive_group(required=True)
    exclusive_actions_group.add_argument("-C","--command", help="command to execute remotely should quoted")
    exclusive_actions_group.add_argument("-S","--script", help="path to the script to execute")

    # this command are mutually exclusive for host list or inventory file, and at least one must be specified
    exclusive_inventory_group = argparser.add_mutually_exclusive_group(required=True)
    exclusive_inventory_group.add_argument("-H","--hosts", help="host or comma separated list of hosts")
    exclusive_inventory_group.add_argument("-I","--inventory", help="path to inventory file")

    # list of optional commands
    argparser.add_argument("-U","--username", help="username")
    argparser.add_argument("-P","--password", help="password")
    argparser.add_argument("-p","--protocol", choices=['ssh', 'telnet'], default=PROTOCOL_SSH, help="protocol to use valid values are ssh (default)or telnet")
    # if specified dryrun is set to true
    argparser.add_argument("-d","--dryrun", help="only shows what will be done", action="store_true")

    argparser.add_argument("-v","--version", action='version',  help="output version information and exit", version=str('%(prog)s ' + VERSION + "("+RELEASE_DATE+")"))
    #argparser.add_argument("-h","--help", help="display this help and exit")


    # parse args
    args=argparser.parse_args()

    try:
        import signal
        # traps the sigint signal
        signal.signal(signal.SIGINT, signal_handler)
    except:
        pass

    DRYRUN=False

    # set username and password
    user=User()
    user.SetFromArgs(args.username, args.password)

    # add hosts to list
    if args.hosts != None:
        hosts=Hosts()
        hosts.AddFromArgs(args.hosts)

    elif args.inventory != None:
        #read host list from inventory
        pass

    connection=Connection(args.protocol)

    if args.command != None:
        for host in hosts.hosts:
            _msgout ("-> " + str(host) + " connection with username: '" + user.username+"'")
            connection.Connect(hostname=host, username=user.username,password=user.password)
            if not connection.connected:
                _msgout (" can't connect!\n")
                continue

            _msgout (" ok!\n")
            _msgout ("-> " + str(host) + " exec command: '" + args.command +"'\n")
            if connection.Exec(args.command):
                if connection.Output() != "" and connection.Output() != None:
                    _msgout ("-> " + str(host) + " output:\n")
                    _msgout ("-----------------------------------------------------------------------------------------------------------------------\n")
                    _msgout (connection.Output() + "\n")
                    _msgout ("-----------------------------------------------------------------------------------------------------------------------\n")
            connection.Close()
            _msgout ("-> " + str(host) + " connection closed.\n")


    elif args.script != None:
        pass

if __name__ == "__main__":
    main()
    sys.exit(EXIT_SUCCESS)


